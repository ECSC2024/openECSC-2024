# CyberChallenge.IT 2024 - University CTF

## [crypto] CookieLogin Revenge (1 solve)

In 2024 we have no time to type passwords anymore...

`nc cookielogin.challs.external.open.ecsc2024.it 38200`

Author: Matteo Rossi <@mr96>

## Overview

The challenge provides us with a simple registration/login system. We can register accounts and obtain a "cookie", generated by the server, that we can use together with our username to login. Our objective is to login as "admin" but, of course, that account is already registered and cannot be registered again.

## Solution

Cookies are generated by signing the hash of the username with a [Rabin](https://en.wikipedia.org/wiki/Rabin_signature_algorithm)-like signature scheme. The hash function is the following.

```py
def hash_msg(m):
    return os.urandom(2) + bytes([0xbb]*90) + bytes([0xba]) + md5(m).digest() + bytes([0xcc])
```

The signature works as follows:

- a modulus $n=pq$ with $p,q$ being primes is generated, where $p\equiv 3 \pmod{8}$ and $q\equiv 7 \pmod{8}$
- the modular square root $s$ of the hashed username is taken modulo $n$, using the chinese remainder theorem
- the smallest of the two roots is returned

The verification algorithm computes the square of the given signature and checks if its last 864 bits are equal to the ones in the hashed username. This is done because the upper bits of the hashed message depend on the results of a random, while the lower ones are fixed.

Let's analyze the signing function a little bit more.

At the beginning a random mask is sampled, squared and multiplied by the hashed username. Notice that this value is even since all hashes with this specific function are even by construction. The function then makes this value a quadratic residue modulo $n$ by eventually dividing by 2 (this works because of how the two primes are chosen $\mod{8}$, but it's not really relevant for the solution). The square root of this value is then taked by CRT, and the mask is removed by multiplying by the multiplicative inverse of the mask $\mod{n}$.

What is the issue here? The issue is that if the mask is not a quadratic residue $\mod n$, it will not be removed completely. In fact, the CRT steps returns the result of the square root of the hashed message multiplied by the principal square root of the mask (the only square root that is a quadratic residue; this is true because squaring is a permutation over the quadratic residues $\mod n$), so, if the mask is not the correct root, it will not be removed.

How do we exploit this? Let's suppose that we can sign two times the same message: we will obtain two signatures $s_1$, $s_2$. In the (likely) case that the mask is not a quadratic residue modulo both $p$ and $q$ in both cases, we will have $s_1 \neq s_2$. But by construction it holds $s_1^2 \equiv s_2^2 \pmod{n}$. So $\gcd(s_1-s_2,n)$ is a non-trivial factor of $n$ with high probability, and this allows us to factor it.

At this point, the only remaining step is to obtain two signatures of the same message. Looking back to the `hash_msg` function, we notice that the only user-controlled part is passed inside the `md5` function. This means that crafting a collision over `md5` should be enough, and we know that this is doable since `md5` is completely broken.

The last thing to adjust is the random at the beginning, but to address it, it is sufficient to craft about 300 `md5` multicollisions and the birthday paradox will do the job :)

The code to generate `md5` multicollisions is provided below for completeness, together with the full solution script, but it was not intended to be written during the competition. A lot of online repositories can be found just by googling "md5 multicollisions".

## Exploit

```py
#!/usr/bin/env python3

import itertools
import logging
import os
import random
import subprocess
from hashlib import md5
from math import gcd
import time
from Crypto.Util.number import bytes_to_long
from pwn import remote

logging.disable()

HOST = os.environ.get("HOST", "cookielogin.challs.external.open.ecsc2024.it")
PORT = int(os.environ.get("PORT", 38200))


class Multicollision_MD5:
    def __init__(self, n_blocks, prefix, dir_path):
        self.n_blocks = n_blocks
        self.dir_path = dir_path
        self.blocks = []
        self.to_create = True
        if not os.path.isdir(self.dir_path):
            os.mkdir(self.dir_path)
        if not os.path.isfile(f"{self.dir_path}/prefix") or not open(f"{self.dir_path}/prefix", "rb").read() == prefix:
            with open(f"{self.dir_path}/prefix", "wb") as wf:
                wf.write(prefix)
        # Check if blocks already exist
        elif all(os.path.isfile(f"{self.dir_path}/block_{i}_{j}") for i in range(n_blocks) for j in range(2)):
            self.to_create = False

    def fastcoll(self, block_id):
        if block_id == 0:
            finp = f"{self.dir_path}/prefix"
        else:
            finp = f"{self.dir_path}/msg_{block_id - 1}_0"

        fout_0 = f"{self.dir_path}/msg_{block_id}_0"
        fout_1 = f"{self.dir_path}/msg_{block_id}_1"
        subprocess.run(["md5_fastcoll", "-p", finp, "-o", fout_0, fout_1])

    def create_blocks(self):
        if self.to_create:
            # Creating prefix collisions
            for block_id in range(self.n_blocks):
                print(f"[+] Block {block_id}")
                self.fastcoll(block_id)

            # Creating single blocks
            prev_len = 0
            for i in range(self.n_blocks):
                for j in range(2):
                    with open(f"{self.dir_path}/msg_{i}_{j}", "rb") as f:
                        msg = f.read()
                        self.blocks.append(msg[prev_len:])
                prev_len = len(msg)

            # Saving blocks
            for i in range(self.n_blocks):
                for j in range(2):
                    with open(f"{self.dir_path}/block_{i}_{j}", "wb") as f:
                        f.write(self.blocks[2 * i + j])
        else:
            for i in range(self.n_blocks):
                for j in range(2):
                    with open(f"{self.dir_path}/block_{i}_{j}", "rb") as f:
                        self.blocks.append(f.read())

    def get_collisions(self):
        if len(self.blocks) == 0:
            self.create_blocks()

        for block_idxs in itertools.product([0, 1], repeat=self.n_blocks):
            msg = b"".join(self.blocks[i * 2 + block_idxs[i]] for i in range(self.n_blocks))
            yield msg


def legendre(h, p):
    if h % p == 0:
        return 0
    elif pow(h, (p - 1) // 2, p) == 1:
        return 1
    else:
        return -1


def hash_msg(m):
    return os.urandom(2) + bytes([0xbb] * 90) + bytes([0xba]) + md5(m).digest() + bytes([0xcc])


def create_cookie(p, q, c, n, user):
    mask = random.randint(2, n - 2)
    inv_mask = pow(mask, -1, n)
    mask = pow(mask, 2, n)
    h = bytes_to_long(hash_msg(user)) * mask

    if legendre(h, p) * legendre(h, q) != 1:
        h = h // 2

    v1 = pow(h, (p + 1) // 4, p)
    v2 = pow(h, (q + 1) // 4, q)
    s = (q * ((c * (v1 - v2)) % p) + v2) % n
    s = s * inv_mask % n
    return min(s, n - s)


def register_user(user):
    chall.sendlineafter(b"> ", b"1")
    chall.sendlineafter(b": ", user.hex().encode())
    cookie = int(chall.recvline().decode().split(": ")[1])
    return cookie


def login_admin(p, q, n):
    user = b"admin"
    c = pow(q, -1, p)
    cookie = create_cookie(p, q, c, n, user)
    chall.sendlineafter(b"> ", b"2")
    chall.sendlineafter(b": ", user.hex().encode())
    chall.sendlineafter(b": ", str(cookie).encode())
    print(chall.recvline().decode())


with remote(HOST, PORT) as chall:
    n = int(chall.recvline().decode().split(" = ")[1])
    multicoll = Multicollision_MD5(12, b"", os.path.join(os.path.dirname(__file__), "Blocks"))
    vals = []
    for user in multicoll.get_collisions():
        cookie = register_user(user)
        for s in vals:
            hope = gcd(s + cookie, n)
            if hope != 1 and hope != n:
                p = hope
                q = n // hope
                login_admin(p, q, n)
                exit()
        vals.append(cookie)
```
