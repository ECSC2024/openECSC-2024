# CyberChallenge.IT 2024 - University CTF

## [crypto] CookieLogin (6 solves)

In 2024 we have no time to type passwords anymore...

`nc cookielogin.challs.external.open.ecsc2024.it 38200`

Author: Matteo Rossi <@mr96>

## Overview

The challenge provides us with a simple registration/login system. We can register accounts and obtain a "cookie", generated by the server, that we can use together with our username to login. Our objective is to login as "admin" but, of course, that account is already registered and cannot be registered again.

## Solution

Cookies are generated by signing the hash of the username with a [Rabin](https://en.wikipedia.org/wiki/Rabin_signature_algorithm)-like signature scheme. The hash function is the following.

```py
def hash_msg(m):
    return bytes([0xbb]*90) + os.urandom(2) + bytes([0xba]) + md5(m).digest() + bytes([0xcc])
```

The signature works as follows:

- a modulus $n=pq$ with $p,q$ being primes is generated
- the modular square root $s$ of the hashed username is taken modulo $n$, using the chinese remainder theorem
- the smallest of the two roots is returned

The verification algorithm computes the square of the given signature and checks if its last 136 bits are equal to the ones in the hashed username. This is done because the upper bits of the hashed message depend on the results of a random, while the lower ones are fixed.

Unfortunately, this challenge had an unintended solution: computing a square root of $n-s$, where $s$ is `md5(b'admin').digest() + bytes([0xcc])`, over `Zmod(2**136)` was enough to have a valid signature. This is because `136*2` is less than the number of bits of the modulus, so the modulus does not affect the computation of the square of the checked part.

You can read the writeup of the fixed version [here](../crypto05/writeup.md).
