# openECSC 2024 - Round 3

## [rev] Cop (35 solves)

Show your license to the officer.

Author: Fabio Zoratti <@orsobruno96>

## Introduction

The challenge file is a standard compiled C program, stripped. After finding the `main` function, we can see that this program installs some linux signal handlers, for SIGSEGV and SIGTRAP.

After the handler installation, the program asks for user input, performs some modifications to that buffer and then it checks if it is equal to a constant string, that we will call `target`. If the modified user input is equal to the target, then the program prints the flag.

The modifications done to the user input seem really obfuscated, for example

```as
mov rdi, 0x901f060022
push r9
pop rdx
mov rax, 0x686130d890c7dc56
nop
sub rdx, r11
mov r9, rdx
sub r11, r9
sub rcx, 0x3b0
int3
mov r9, r10
add r11, r10
mov rax, 0x4853a66338a6fc1f
sub r10, 0x930
mov r9, rcx
sub r11, rcx
sub r11, r10
mov r11, 0xf451
mov rdx, 0x309a0f001d
```

that doesn't look like anything reasonable.

## Reversing the binary

We can do some reverse work on the signal handlers to understand better what is happening. We see that the hanlders are reading the `ucontext` parameter of the handler, that have some interesting fields, like `ucontext->uc_mcontext.gregs` that contains all the registers values at the moment of the signal dispatching.

With some some difficulties, we can reconstruct some pseudocode for the sigsegv handler

```c
  u8 opcode = SBITMASK(regs->uc_mcontext.gregs[REG_RAX], 23, 31);


  switch (opcode) {
  case 0x56:
    *addr += operand;
    break;
  case 0x71:
    *addr ^= operand;
    break;
  default:
    exit(-11);
  }
```

where we undestand that some bits of the register `rax` are read in order to decide which operation to perform, looking like a VM. For the sigsegv handler, the arguments for the operation are taken from the faulty address (`cr2` register) and a constant value in the register `r8`, that is never touched

```c
  u16 offset = SBITMASK(regs->uc_mcontext.gregs[REG_CR2], 0, 16);
  u8 operand = SBITMASK(regs->uc_mcontext.gregs[REG_CR2], 16, 24);
  char* addr = (char*) regs->uc_mcontext.gregs[REG_R8] + offset;
```

All the segmentation faults seem to be generated by instructions of the form

```as
mov qword ptr [reg], imm64
```

where `reg` is not always the same.

The sigtrap signals are instead generated by some `int3` istructions, and the handler is similar to the sigsegv. The main difference is that the opcodes are different and do different stuff, and the parameters are taken from `rdi` instead of `cr2`.

All the operations done by the handlers seem invertible (add, sub, xor, rol, ror), so it is possible, at least in principle, to track all the handler calls and keep track of the modifications done to the buffer, and invert them. It is however rather daunting trying to do it by hand, because there are a lot of instructions, and it is even worse to think about scripting it.

## Writing the solution

First of all we can disassemble all the instructions of the scrambler and split them when we find the instructions that trigger SIGSEGV and SIGTRAP

```py
from pwn import context, ELF

exe = context.binary = ELF("src/cop.dbg")


def get_splitted_instructions():
    instructions = exe.disasm(
        exe.sym['scrambler'], 3000,
    )
    sequence = []
    accumulator = []

    for line in instructions.split("\n"):
        accumulator.append(line)
        if "int3" in line or "mov    QWORD PTR" in line:
            sequence.append(accumulator)
            accumulator = []
        if "ret" in line:
            break
    else:
        raise ValueError("Need to disassemble more")
    return sequence
```

Let's suppose to have already written an abstract parser that takes the instruction list that ends with `int3` or `mov qword ptr [reg]` and produces a struct `Operation` of this kind:

```py
from enum import IntEnum
from collections import namedtuple

Operation = namedtuple("Operation", ["opcode", "offset", "operand"])


class Opcode(IntEnum):
    Add = 0x56
    Xor = 0x71
    Sub = 0x90
    Rol = 0x13
    Ror = 0x21
```

With this, we can write a simple function that computes the correct flag, performing an inversion of the operations

```py
target = exe.read(exe.sym['target'], 0x30)


def invert_target(operations: list[Operation]):
    ret = [i for i in target]
    for op in operations:
        if op.opcode == Opcode.Add:
            ret[op.offset] = (ret[op.offset] - op.operand) % 256
            continue
        if op.opcode == Opcode.Xor:
            ret[op.offset] ^= op.operand
            continue
        if op.opcode == Opcode.Sub:
            ret[op.offset] = (ret[op.offset] + op.operand) % 256
            continue
        if op.opcode == Opcode.Rol:
            ret[op.offset] = ror(ret[op.offset], op.operand, 8)
            continue
        if op.opcode == Opcode.Ror:
            ret[op.offset] = rol(ret[op.offset], op.operand, 8)
            continue
        raise ValueError(f"Invalid opcode {op.opcode}")
    return bytes(ret).decode().replace("\x00", "")
```

that can be used to compute directly the flag

```py
    flag = invert_target(instructions)
    print(f"flag{{{flag}}}")
```

Now we need to understand how to parse each code snippet. I personally think (@orsobruno96) that the least painfully way to parse these snippets is to emulate their execution, for example using unicorn emulator

```py
from unicorn import Uc, x86_const, UC_ARCH_X86, UC_MODE_64


def bitmask(val, low, hi):
    return (val & (((1 << hi) - 1) ^ ((1 << low) - 1)))


def sbitmask(val, low, hi):
    return bitmask(val, low, hi) >> low


def reg_to_args(val: int):
    offset = sbitmask(val, 0, 16)
    operand = sbitmask(val, 16, 24)
    return offset, operand


def x86_to_opcode(instset: list[str]):
    emu = Uc(UC_ARCH_X86, UC_MODE_64)
    start_addr = int(instset[0].split(":")[0], 16)
    end_addr = int(instset[-1].split(":")[0], 16)
    bytecode = exe.read(start_addr, end_addr - start_addr)

    START = 0x4000
    STACK = 0x100000
    emu.mem_map(START, 0x1000)
    emu.mem_map(STACK, 0x200000)
    emu.mem_write(START, bytecode)
    emu.reg_write(x86_const.UC_X86_REG_RSP, STACK + 0x5000)
    emu.emu_start(START, START + end_addr - start_addr)
    rax = emu.reg_read(x86_const.UC_X86_REG_RAX)
    opcode = Opcode(sbitmask(rax, 23, 31))

    if "int3" in instset[-1]:
        reg = emu.reg_read(x86_const.UC_X86_REG_RDI)
    elif "QWORD PTR" in instset[-1]:
        regname = search(r"QWORD PTR \[([a-z0-9A-Z]+)\]", instset[-1]).group(1)
        reg = emu.reg_read(getattr(x86_const, f"UC_X86_REG_{regname.upper()}"))
    else:
        raise ValueError(f"Invalid instset: {instset}")
    offset, operand = reg_to_args(reg)
    return Operation(opcode, offset, operand)
```

Putting all together we obtain the flag.

```py

def main():
    sequence = get_splitted_instructions()
    instructions = [
        x86_to_opcode(inst) for inst in sequence
    ]
    flag = invert_target(instructions)
    print(f"flag{{{flag}}}")


if __name__ == '__main__':
    main()

```
