# openECSC 2024 - Round 3

## [rev] livestream (21 solves)

everyone talks at the same time, how can I understand?

Author: Andrea Raineri <@Rising>

## Overview

The challenge delivers two attachments:

- an executable file
- a binary data file, generated from the executable

The executable takes as argument the flag and outputs the binary file from which the flag can be extracted. The file is generated as the concatenation of 64 64x64 matrices of long ints, each one embedding some informations being generated by each of the 64 threads running concurrently, simulating multiple devices talking over a shared communication medium using Code Division Multiple Access techniques to avoid collisions and allow any listener to recover completely the original data generated by each thread.

Following the CDMA pattern, each thread was associated a vector of 64 elements in {-1,1}, which were generated from an Hadamard matrix to have the particular property of being pair-wise ortogonal

```python
import numpy as np

SIZE = 64

def make_hadamard_matrix(n) -> np.ndarray:
    if n == 1:
        return np.array([1])
    else:
        submatrix = make_hadamard_matrix(n // 2)
        submatrix = np.concatenate((np.vstack((submatrix, submatrix)), np.vstack((submatrix, -submatrix))), axis=1)
        return submatrix
    
x = make_hadamard_matrix(SIZE).reshape((SIZE,SIZE))
```

These codes were saved in .bin files as 64-bits numbers translating -1 -> 1 and 1 -> 0.

In the executable, each thread reads its code and uses it in outer product with vectors of 64 bytes to be "sent" over the shared communication channel (the 64x64 matrices).

2*64 matrices are produced in the output file, each couple representing a time slot of transmission. For each couple of matrices:

1. The first one contains information produced from the corresponding thread (thread id == time slot index). Each thread, apart from thread 34 (which is writing info from the flag), writes a letter from the string `0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWX{}_!`. When not in their time slot threads write random data on the matrix
2. Each thread, when in its time slot, writes its code

Thread 34 behaves differently:

1. in the first matrix of the i-slot writes `char_string.index(flag[i])`
2. does not share its code in the 34th time slot

Finally, `t2` thread takes care of outputting the matrices to stdout when all the 64 talking threads have performed their operations, after performing the xor with the constant `0x1337dead1337beef`

## Solution

- xor with the constant to get the original output of all the threads
- recover the 63 codes shared by the threads
- compute the last missing code for the thread with flag informations. This step could be accomplished in different ways:
  - using a SAT solver after setting the required constraints
  - solving the linear system of equations obtained from the other codes, looking for a vector with values in {-1, 1} ortogonal to all other codes
  - leverage the way codes are crafted (Hadamard matrices), noticing that the XOR of all generate codes interpreted as binary numbers (using the mapping -1 -> 1, 1 -> 0) is 0, thus allowing to recover the missing code by xoring the 63 already recovered
- Using the computed missing code for thread 34, extract the letters of the flag from each time slot

## Exploit

```python
# Path: solution.py

import numpy as np
import struct
import sys
import functools

CHARS = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWX{}_!"
KEY = 0x1337dead1337beef

with open(sys.argv[1], 'rb') as f:
    out = f.read()

parsed = []

for i in range(0, len(out), 8):
    parsed.append(struct.unpack('<q', out[i:i+8])[0] ^ KEY)

segments = []
for i in range(0, len(parsed), 64*64):
    segments.append(np.array(parsed[i:i+64*64], dtype=np.int64).reshape((64,64)))

codes = {}
for i in range(0, len(segments), 2):
    tx = segments[i]
    carrier = segments[i+1]
    id = i//2
    code = np.zeros(64, dtype=np.int8)
    for j, x in enumerate(carrier[:32]):
        if not all(x == 0):
            code = x
            break

    code = int.from_bytes(np.packbits(code).tobytes(), 'big')
    codes[id] = code

# COMPUTE MISSING CODE
code = functools.reduce(lambda a, b: a ^ b, codes.values())
print(code)
code = np.array([-1 if (code >> _) & 1 else 1 for _ in range(64)][::-1])

flag = ""
for i in range(64):
    d = segments[i << 1]@code//64
    flag += CHARS[d[0]&0xff]
print(flag)
```

```bash
python3 solution.py output.bin
```
